# mc_world.gd
class_name MCWorld
extends Node3D # Base node for the world

# --- Configuration Properties ---
@export_group("Dimensions")
@export var world_size_x_in_chunks : int = 2
@export var world_size_y_in_chunks : int = 2
@export var world_size_z_in_chunks : int = 1
@export var chunk_size : int = 16 # Size of each chunk in voxels (e.g., 16x16x16)
@export var voxel_size : float = 1.0 # Size of each voxel in world units (meters)

@export_group("Data & Visuals")
# This holds the actual density data and generation logic
# Assign a DensityGrid or LevelDensityGrid resource here in the inspector
@export var density_grid_instance : DensityGrid = null

# Alternatively, create a LevelDensityGrid instance via script:
# @export var create_level_grid_on_ready := true
# var level_density_grid_instance : LevelDensityGrid = null

# Scene/PackedScene for the chunk actor
@export var chunk_scene : PackedScene = null # Assign your MCChunk scene here

# Material for the generated mesh
@export var terrain_material : Material = null


# --- Runtime Info ---
# Array of spawned chunk nodes
var chunks : Array[Node] = []
# World space spawn/end points calculated by density grid
var world_spawn_point : Vector3 = Vector3.ZERO
var world_end_point : Vector3 = Vector3.ZERO

# Reference to the node holding the chunks for organization
@onready var chunk_container : Node3D = $ChunkContainer


# --- Initialization ---
func _ready():
	# Create container if it doesn't exist (optional, can be done in editor)
	if not has_node("ChunkContainer"):
		chunk_container = Node3D.new()
		chunk_container.name = "ChunkContainer"
		add_child(chunk_container)

	# Optionally auto-generate world on ready
	generate_world()


# --- Generation Control ---

# Call this to start the generation process
func generate_world():
	_clear_world() # Clear previous state first

	print("--- Starting World Generation ---")

	# 1. Generate Density Data
	if not _generate_density_data():
		printerr("Failed to generate density data. Aborting world generation.")
		return

	# 2. Spawn Chunks to Visualize
	_spawn_chunks()

	print("--- World Generation Complete ---")
	print("Spawn: %s, End: %s" % [world_spawn_point, world_end_point])


# Internal step to create and populate the density grid
func _generate_density_data() -> bool:
	print("Generating Density Data...")

	# Ensure we have a Density Grid instance
	if density_grid_instance == null:
		# Option: Create a default if needed (and configured to do so)
		#if create_level_grid_on_ready:
		#    level_density_grid_instance = LevelDensityGrid.new()
		#    density_grid_instance = level_density_grid_instance # Assign to the one we use
		#    print("Created new LevelDensityGrid instance.")
		#else:
		printerr("DensityGridInstance is not set. Assign a DensityGrid resource (e.g., LevelDensityGrid) in the editor.")
		return false

	# Check if the assigned instance is a LevelDensityGrid for procedural generation
	var level_gen_grid = density_grid_instance as LevelDensityGrid
	if level_gen_grid == null:
		printerr("Assigned DensityGridInstance is not a LevelDensityGrid. Skipping procedural level generation.")
		# Ensure the base grid is initialized if it's just a basic DensityGrid
		if density_grid_instance.get_grid_dimensions() == Vector3i.ZERO:
			printerr("Non-LevelDensityGrid instance has zero dimensions. Initializing with defaults.")
			var total_dims = _get_total_grid_dimensions()
			density_grid_instance.initialize_grid(total_dims.x, total_dims.y, total_dims.z, density_grid_instance.WORLD_SOLID_VALUE) # Init solid
	else:
		# It's a LevelDensityGrid, so call its generation function
		print("Calling generate_level_data on LevelDensityGrid instance...")
		var total_dims = _get_total_grid_dimensions()
		level_gen_grid.generate_level_data(total_dims, voxel_size)


		# Get spawn/end points calculated by the LevelDensityGrid and offset by world location
		# Note: Original C++ adds actor location. Here, we assume the MCWorld node IS the origin.
		# If MCWorld is offset, add 'global_position' here.
		world_spawn_point = level_gen_grid.calculated_spawn_position # Already includes voxel_size scaling
		world_end_point = level_gen_grid.calculated_end_position   # Already includes voxel_size scaling

		print("Density Data generated by LevelDensityGrid. Calculated Spawn: %s, End: %s" % [level_gen_grid.calculated_spawn_position, level_gen_grid.calculated_end_position])

	return true


# Internal step to spawn chunk actors based on density data
func _spawn_chunks():
	if chunk_container == null:
		printerr("ChunkContainer node not found!")
		return
	if density_grid_instance == null or density_grid_instance.get_grid_dimensions() == Vector3i.ZERO:
		printerr("DensityGridInstance is not valid or not initialized! Cannot spawn chunks.")
		return

	var num_chunks_x : int = world_size_x_in_chunks
	var num_chunks_y : int = world_size_y_in_chunks
	var num_chunks_z : int = world_size_z_in_chunks

	print("Spawning %d x %d x %d = %d chunks..." % [num_chunks_x, num_chunks_y, num_chunks_z, num_chunks_x * num_chunks_y * num_chunks_z])

	for chunk_z in range(num_chunks_z):
		for chunk_y in range(num_chunks_y):
			for chunk_x in range(num_chunks_x):
				# Calculate world position offset for this chunk
				var chunk_world_location_offset := Vector3(
					float(chunk_x * chunk_size) * voxel_size,
					float(chunk_y * chunk_size) * voxel_size,
					float(chunk_z * chunk_size) * voxel_size
				)
				# Position relative to MCWorld's origin
				var chunk_world_location : Vector3 = chunk_world_location_offset

				# Instantiate the chunk scene
				var spawned_chunk = MCChunk.new()

				if spawned_chunk is MCChunk: # Type check
					var chunk_node : MCChunk = spawned_chunk # Cast for type hints

					# Calculate grid offset for this chunk
					var offset_x : int = chunk_x * chunk_size
					var offset_y : int = chunk_y * chunk_size
					var offset_z : int = chunk_z * chunk_size

					# --- Configure the Chunk ---
					chunk_node.density_grid = density_grid_instance
					chunk_node.chunk_grid_offset = Vector3i(offset_x, offset_y, offset_z)
					chunk_node.chunk_size = self.chunk_size
					chunk_node.voxel_size = self.voxel_size
					chunk_node.terrain_material = self.terrain_material

					# Set position and add to container
					chunk_node.position = chunk_world_location
					chunk_container.add_child(chunk_node)
					chunks.append(chunk_node) # Keep track of the node

					# Trigger mesh generation AFTER setting data and adding to scene tree
					# CallDeferred ensures it runs after the node is fully ready in the tree
					chunk_node.call_deferred("generate_mesh_from_density_grid")
					#chunk_node.generate_mesh_from_density_grid()

				else:
					printerr("Failed to instantiate chunk or instantiated scene is not an MCChunk at grid position [%d, %d, %d]!" % [chunk_x, chunk_y, chunk_z])
					if spawned_chunk: # If it instantiated but wasn't the right type
						spawned_chunk.queue_free() # Clean up

	print("Chunk spawning initiated. Spawned %d chunks." % chunks.size())


# --- Helper Functions ---

# Helper to calculate total grid dimensions based on chunk layout
# (+1 because marching cubes samples corners)
func _get_total_grid_dimensions() -> Vector3i:
	var total_grid_dim_x : int = world_size_x_in_chunks * chunk_size + 1
	var total_grid_dim_y : int = world_size_y_in_chunks * chunk_size + 1
	var total_grid_dim_z : int = world_size_z_in_chunks * chunk_size + 1
	return Vector3i(total_grid_dim_x, total_grid_dim_y, total_grid_dim_z)


# Helper to clear existing world state
func _clear_world():
	print("Clearing existing world state...")
	# Destroy existing chunks
	for chunk in chunks:
		if is_instance_valid(chunk):
			chunk.queue_free()
	chunks.clear()

	# Optionally reset density grid if needed (or reuse existing one)
	# if density_grid_instance:
	#     # Reset specific properties or re-initialize
	#     pass

	world_spawn_point = Vector3.ZERO
	world_end_point = Vector3.ZERO
